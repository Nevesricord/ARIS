
import os
import re
import speech_recognition as sr
import asyncio
import edge_tts
import pygame
import difflib
import threading
import time
import sys
import random
import unicodedata
import pyaudio

# --- Importa√ß√µes PyQt6 ---
from PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, 
                             QHBoxLayout, QPushButton, QTextEdit, QLabel, QFrame, 
                             QSizePolicy, QLineEdit, QFileDialog, QProgressBar)
from PyQt6.QtCore import QObject, QThread, pyqtSignal, Qt
from PyQt6.QtGui import QFont, QPixmap, QMovie, QIcon

# --- IMPORTA√á√ïES PARA PROCESSAMENTO E RECOMENDA√á√ÉO ---
import pandas as pd
import torch
from sentence_transformers import SentenceTransformer, util
import requests
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.lib.units import inch
# -----------------------------------------------

# --- IMPORTA√á√ïES API HUGGING FACE ---
from openai import OpenAI 
# ------------------------------------

# ====================================================================
# 1. CLASSES DE CONFIGURA√á√ÉO E RECOMENDA√á√ÉO
# ====================================================================

class SplashScreen(QWidget):
    def __init__(self):
        super().__init__()
        self.setFixedSize(400, 250)
        # Faz a janela n√£o ter bordas e ficar sempre no topo
        self.setWindowFlags(Qt.WindowType.SplashScreen | Qt.WindowType.FramelessWindowHint | Qt.WindowType.WindowStaysOnTopHint)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)

        # Layout principal
        layout = QVBoxLayout(self)
        
        # Frame para o conte√∫do com bordas arredondadas e sombra
        self.frame = QFrame(self)
        self.frame.setStyleSheet(f"""
            QFrame {{
                background-color: {ArisConfig.WIDGET_COLOR};
                border-radius: 15px;
                border: 1px solid {ArisConfig.PRIMARY_COLOR};
                font-size: 14px; /* Arial */
            }}
        """)
        layout.addWidget(self.frame)

        content_layout = QVBoxLayout(self.frame)
        content_layout.setContentsMargins(10, 10, 10, 10)
        
        # Logo
        self.logo_label = QLabel()
        pixmap = QPixmap(ArisConfig.PROFILE_PIC_PATH)
        self.logo_label.setPixmap(pixmap.scaled(200, 100, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation))
        self.logo_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        content_layout.addWidget(self.logo_label)

        # Texto de Status
        self.status_label = QLabel("Iniciando ARIS...")
        self.status_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.status_label.setStyleSheet("font-size: 18px; color: #000000;") # Mantido 14px para status
        content_layout.addWidget(self.status_label)

        # Barra de Progresso
        self.progress_bar = QProgressBar(self)
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setTextVisible(False)
        self.progress_bar.setStyleSheet(f"""
            QProgressBar {{
                border: 1px solid {ArisConfig.ACCENT_COLOR};
                border-radius: 5px;
                background-color: #333;
                height: 10px;
            }}
            QProgressBar::chunk {{
                background-color: {ArisConfig.PRIMARY_COLOR};
                border-radius: 5px;
            }}
        """)
        content_layout.addWidget(self.progress_bar)

    def set_progress(self, value):
        self.progress_bar.setValue(value)

    def set_status(self, text):
        self.status_label.setText(text)


class InitializationWorker(QObject):
    """
    Worker que executa as tarefas pesadas de inicializa√ß√£o em uma thread separada.
    """
    progress_updated = pyqtSignal(int, str)  # (progresso, texto_status)
    finished = pyqtSignal(object)       # (modelo_carregado) - SINAL CORRIGIDO

    def run(self):
        try:
            # Tarefa 1: Inicializar Pygame (R√°pido)
            self.progress_updated.emit(30, "Inicializando sistema de √°udio...")
            pygame.init()
            pygame.mixer.init()
            if os.path.exists(ArisConfig.MUSIC_FILE):
                pygame.mixer.music.load(ArisConfig.MUSIC_FILE)
                pygame.mixer.music.set_volume(0.3)
            time.sleep(0.5)

            # Tarefa 2: Carregar o Modelo de IA (LENTO)
            self.progress_updated.emit(60, "Carregando modelo de IA (pode demorar)...")
            modelo = SentenceTransformer(ArisConfig.MODELO_EMBEDDING)
            
            self.progress_updated.emit(100, "Tudo pronto!")
            time.sleep(1) # Uma pequena pausa para o usu√°rio ver a conclus√£o

            # Emite o sinal de finalizado com os resultados (apenas o modelo)
            self.finished.emit(modelo)

        except Exception as e:
            # Em caso de erro, podemos notificar o usu√°rio
            print(f"Erro na inicializa√ß√£o: {e}")
            self.finished.emit(None) # Envia None para indicar falha


class ArisConfig:
    ASSETS_DIR = "maker"
    PROFILE_PIC_PATH = os.path.join(ASSETS_DIR, "logo_sesi.png") 
    THINKING_GIF_PATH = os.path.join(ASSETS_DIR, "thinking.gif") 
    PRIMARY_COLOR = "#A61010" 
    ACCENT_COLOR = "#D13355" 
    BACKGROUND_COLOR = "#E9E8E7" 
    WIDGET_COLOR = "#E4DCE4" 
    TEXT_COLOR = "#050505" 
    TEXT_LOG_COLOR = "#000000" 
    ERROR_COLOR = "#CB313E" 
    VOICE = "pt-BR-FranciscaNeural"
    MUSIC_FILE = "aris.audio.mp3"
    MODELO_EMBEDDING = 'paraphrase-multilingual-mpnet-base-v2'

class RecomendadorVetorial:
    
    def __init__(self, pasta_acervo, modelo_precarregado=None):
        self.MODELO_EMBEDDING = ArisConfig.MODELO_EMBEDDING
        self.NOME_ARQUIVO_DADOS = os.path.join(pasta_acervo, 'acervo_processado.csv')
        self.NOME_ARQUIVO_EMBEDDINGS = os.path.join(pasta_acervo, 'embeddings.pt')
        self.modelo = modelo_precarregado
        self.acervo_df = None
        self.embeddings = None
        self.carregado = False

    def carregar_modelo_e_dados(self):
        try:
            if self.modelo is None:
                print("Carregando o modelo de linguagem para recomenda√ß√£o...")
                self.modelo = SentenceTransformer(self.MODELO_EMBEDDING)

            if not os.path.exists(self.NOME_ARQUIVO_DADOS) or not os.path.exists(self.NOME_ARQUIVO_EMBEDDINGS):
                print(f"ERRO: Arquivos de acervo n√£o encontrados na pasta.")
                return False

            print("Carregando o acervo de livros e os embeddings...")
            self.acervo_df = pd.read_csv(self.NOME_ARQUIVO_DADOS)
            self.embeddings = torch.load(self.NOME_ARQUIVO_EMBEDDINGS)
            self.acervo_df.fillna({"titulo_original": "", "autor": "", "generos": "", "descricao": ""}, inplace=True)

            print("--- Sistema de Recomenda√ß√£o Vetorial PRONTO! ---")
            self.carregado = True
            return True
        except Exception as e:
            print(f"ERRO CR√çTICO ao carregar o sistema de recomenda√ß√£o: {e}")
            return False

    def recomendar(self, query, top_k=5):
        if not self.carregado or self.modelo is None:
            return []
        query_embedding = self.modelo.encode(query, convert_to_tensor=True)
        cos_scores = util.cos_sim(query_embedding, self.embeddings)[0]
        top_results = torch.topk(cos_scores, k=min(top_k, len(self.acervo_df)))
        livros_recomendados = []
        for score, idx in zip(top_results[0], top_results[1]):
            livro_info = self.acervo_df.iloc[idx.item()].to_dict()
            livro_info['similaridade'] = score.item()
            livros_recomendados.append(livro_info)
        return livros_recomendados

# ====================================================================
# 2. WORKER PARA PROCESSAMENTO DE ACERVO
# ====================================================================

class AcervoProcessorWorker(QObject):
    log_signal = pyqtSignal(str)
    progress_signal = pyqtSignal(str)
    finished_signal = pyqtSignal(bool, str)

    def __init__(self, excel_path, output_dir, api_key):
        super().__init__()
        self.excel_path = excel_path
        self.output_dir = output_dir
        self.api_key = api_key
        self.csv_path = os.path.join(self.output_dir, 'acervo_processado.csv')
        self.pdf_path = os.path.join(self.output_dir, 'catalogo_biblioteca.pdf')
        self.embeddings_path = os.path.join(self.output_dir, 'embeddings.pt')

    def limpar_titulo_para_busca(self, titulo):
        titulo_limpo = re.sub(r'\(.*?\)|\[.*?\]', '', str(titulo)).strip()
        return titulo_limpo

    def carregar_titulos_ja_processados(self):
        if not os.path.exists(self.csv_path): return set()
        try:
            df = pd.read_csv(self.csv_path)
            return set(df['titulo_original'].tolist())
        except pd.errors.EmptyDataError: return set()

    def gerar_pdf(self, dataframe):
        self.progress_signal.emit("Gerando cat√°logo em PDF...")
        doc = SimpleDocTemplate(self.pdf_path, pagesize=letter)
        styles, story = getSampleStyleSheet(), []
        style_titulo, style_body = styles['h2'], styles['BodyText']
        style_titulo.fontName = "Helvetica-Bold"
        style_body.fontName = "Helvetica"
        for _, row in dataframe.iterrows():
            story.append(Paragraph(row['titulo_original'], style_titulo))
            story.append(Paragraph(f"<b>Autor(es):</b> {row['autor']}</b>", style_body))
            story.append(Paragraph(f"<b>G√™neros:</b> {row['generos']}</b>", style_body))
            story.append(Paragraph(row['descricao'], style_body))
            story.append(Spacer(1, 0.25 * inch))
        try:
            doc.build(story)
            self.log_signal.emit(f"LOG: PDF '{self.pdf_path}' gerado com sucesso!")
        except Exception as e:
            self.log_signal.emit(f"LOG: ERRO AO GERAR PDF: {e}")

    def run(self):
        """Fun√ß√£o principal que executa todo o pipeline de processamento."""
        try:
            # ETAPA 1: LER E LIMPAR O EXCEL
            self.progress_signal.emit("Lendo arquivo Excel...")
            df = pd.read_excel(self.excel_path, engine='openpyxl')
            if 't√≠tulo' not in df.columns:
                self.finished_signal.emit(False, "Coluna 't√≠tulo' n√£o encontrada no Excel.")
                return
            titulos_unicos = df['t√≠tulo'].dropna().drop_duplicates().tolist()
            self.log_signal.emit(f"LOG: Encontrados {len(titulos_unicos)} livros √∫nicos.")

            # ETAPA 2: ENRIQUECER COM GOOGLE BOOKS API
            self.progress_signal.emit("Enriquecendo dados com Google Books API...")
            titulos_ja_processados = self.carregar_titulos_ja_processados()
            titulos_a_processar = [t for t in titulos_unicos if t not in titulos_ja_processados]
            novos_livros_data = []
            total_a_processar = len(titulos_a_processar)
            self.log_signal.emit(f"LOG: {len(titulos_ja_processados)} j√° processados. Faltam {total_a_processar}.")

            for i, titulo in enumerate(titulos_a_processar):
                self.progress_signal.emit(f"Buscando ({i+1}/{total_a_processar}): {str(titulo)[:40]}...")
                titulo_busca = self.limpar_titulo_para_busca(titulo)
                url = f"https://www.googleapis.com/books/v1/volumes?q=intitle:{requests.utils.quote(titulo_busca)}&langRestrict=pt&maxResults=1&key={self.api_key}"
                livro_info = {"titulo_original": titulo, "autor": "N/A", "generos": "N/A", "descricao": "N√£o encontrada."}
                try:
                    response = requests.get(url, timeout=10)
                    if response.status_code in [429, 403]:
                        self.log_signal.emit("LOG: Cota da API atingida. Continue o processo amanh√£.")
                        break
                    data = response.json()
                    if "items" in data and data["items"]:
                        info = data["items"][0]["volumeInfo"]
                        livro_info.update({
                            "autor": ", ".join(info.get("authors", ["Desconhecido"])),
                            "generos": ", ".join(info.get("categories", ["N√£o classificado"])),
                            "descricao": info.get("description", "Sem descri√ß√£o.")
                        })
                except requests.exceptions.RequestException:
                    self.log_signal.emit(f"LOG: Erro de rede em '{titulo}'. Pulando.")
                novos_livros_data.append(livro_info)
                time.sleep(0.5) # Pausa para n√£o sobrecarregar a API

            if novos_livros_data:
                df_temp = pd.DataFrame(novos_livros_data)
                df_temp.to_csv(self.csv_path, mode='a', index=False, header=not os.path.exists(self.csv_path))
                self.log_signal.emit(f"LOG: {len(novos_livros_data)} novos livros salvos no CSV.")

            # ETAPA 3: CRIAR EMBEDDINGS
            self.progress_signal.emit("Preparando para gerar embeddings...")
            df_completo = pd.read_csv(self.csv_path)
            df_completo.fillna({"descricao": "Sem descri√ß√£o."}, inplace=True)

            self.progress_signal.emit(f"Carregando modelo '{ArisConfig.MODELO_EMBEDDING}'...")
            model = SentenceTransformer(ArisConfig.MODELO_EMBEDDING)
            df_completo['texto_para_embedding'] = ("T√≠tulo: " + df_completo['titulo_original'].astype(str) + ". Autor: " + df_completo['autor'].astype(str) + ". G√™nero: " + df_completo['generos'].astype(str) + ". Sinopse: " + df_completo['descricao'].astype(str))
            
            self.progress_signal.emit("Gerando embeddings... (pode levar v√°rios minutos)")
            embeddings = model.encode(df_completo['texto_para_embedding'].tolist(), convert_to_tensor=True, show_progress_bar=True)

            # ETAPA 4: SALVAR RESULTADOS
            self.progress_signal.emit("Salvando arquivos finais...")
            torch.save(embeddings, self.embeddings_path)
            self.log_signal.emit(f"LOG: Embeddings salvos em '{self.embeddings_path}'")
            self.gerar_pdf(df_completo)
            
            self.finished_signal.emit(True, self.output_dir)

        except Exception as e:
            error_message = f"ERRO no processamento: {e}"
            self.log_signal.emit(f"LOG: {error_message}")
            self.finished_signal.emit(False, error_message)

# ====================================================================
# 3. VARI√ÅVEIS GLOBAIS E CONFIGURA√á√ÉO DO ASSISTENTE
# ====================================================================

HF_TOKEN, client = None, None
VOICE, MUSIC_FILE = ArisConfig.VOICE, ArisConfig.MUSIC_FILE
RECOMENDADOR = None 
CONVERSA_ATIVA = False
main_async_loop = None 
CHAT_HISTORY, USER_NAME, USER_AGE = [], "Aluno", "N√£o informada"
MAX_TENTATIVAS = 5 

def inicializar_cliente_hf(token):
    global client, HF_TOKEN
    if not token: return False
    try:
        # Usa a classe OpenAI do SDK para acessar a rota do Hugging Face
        client = OpenAI(base_url="https://router.huggingface.co/v1", api_key=token)
        # Testa a conex√£o fazendo uma chamada simples s√≠ncrona (Pode ser removido para evitar overhead)
        # client.chat.completions.create(model="meta-llama/Meta-Llama-3-8B-Instruct", messages=[{"role": "user", "content": "Ol√°"}], max_tokens=10) 
        HF_TOKEN = token
        return True
    except Exception as e:
        print(f"Erro ao inicializar cliente HF: {e}")
        client = None # Garante que o cliente seja None em caso de falha
        return False

# ====================================================================
# 4. FUN√á√ïES AUXILIARES
# ====================================================================

def remover_acentos(texto):
    try:
        return unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('utf-8')
    except Exception:
        return texto

def similar(a, b):
    return difflib.SequenceMatcher(None, a, b).ratio()

# ====================================================================
# 5. THREAD DE CONTROLE DA ARIS (PyQt6 Worker)
# ====================================================================

class ArisWorker(QObject):
    log_signal = pyqtSignal(str)
    status_signal = pyqtSignal(str)
    user_info_signal = pyqtSignal(str, str) 
    activity_animation_signal = pyqtSignal(str) 

    def __init__(self):
        super().__init__()
        self.r = sr.Recognizer()
        self.r.pause_threshold = 2.0 
        self._is_running = True
        self.mic_thread = threading.Thread(target=self._ouvir_palavra_de_ativacao, daemon=True)

    # --- Fun√ß√µes de I/O (falar, ouvir_e_reconhecer) - SEM SERVOS
    async def falar(self, texto):
        filename = "aris_speech_output.mp3"
        try:
            self.log_signal.emit(f"ARIS: {texto}")
            self.status_signal.emit("ARIS Falando...")
            self.activity_animation_signal.emit("talking")
            
            comunicador = edge_tts.Communicate(text=texto, voice=VOICE)
            await comunicador.save(filename)
            
            som_fala = pygame.mixer.Sound(filename)
            canal_fala = pygame.mixer.Channel(0) 
            canal_fala.play(som_fala)
            
            while canal_fala.get_busy():
                await asyncio.sleep(0.1) 
                
        except Exception as e:
            self.log_signal.emit(f"LOG: Erro ao falar: {e}")
        finally:
            if CONVERSA_ATIVA:
                self.status_signal.emit("ARIS Parou. Pr√≥ximo comando...")
                self.activity_animation_signal.emit("idle")
            if os.path.exists(filename):
                os.remove(filename)

    async def ouvir_e_reconhecer(self, recognizer, source):
        self.status_signal.emit("Ouvindo... Pode falar!")
        self.activity_animation_signal.emit("listening") 
        
        try:
            audio = await asyncio.to_thread(recognizer.listen, source, timeout=15, phrase_time_limit=40)
            
            self.activity_animation_signal.emit("idle")
            self.status_signal.emit("Processando...")
            
            pygame.mixer.music.play(loops=-1)
            
            texto = await asyncio.to_thread(recognizer.recognize_google, audio, language="pt-BR")
            
            pygame.mixer.music.stop()
            
            self.log_signal.emit(f"VOC√ä: {texto.lower()}")
            return texto.lower()
        
        except sr.WaitTimeoutError:
            self.log_signal.emit("LOG: O reconhecimento falhou (Timeout).") # Alterado para log sem "ARIS:"
            return ""
        except sr.UnknownValueError:
            self.log_signal.emit("LOG: O reconhecimento falhou (UnknownValue).") # Alterado para log sem "ARIS:"
            return ""
        except Exception as e:
            self.log_signal.emit(f"LOG: Erro no reconhecimento: {e}")
            return ""
        finally:
            self.activity_animation_signal.emit("idle")
    
    # --- L√≥gica de IA ---
    async def gerar_resposta_ia(self, prompt):
        global CHAT_HISTORY
        
        if client is None:
              self.log_signal.emit("LOG: ERRO: Tentativa de usar a API sem estar conectada.")
              return "Aten√ß√£o: A API do Hugging Face n√£o est√° conectada. Por favor, insira e conecte o seu token."
        
        if "Analise:" in prompt:
            messages = [
                {"role": "system", "content": "Voc√™ √© um assistente de extra√ß√£o de dados. Responda APENAS com o dado solicitado e nada mais."}
            ]
            messages.append({"role": "user", "content": prompt})
        else:
            if USER_AGE.isdigit() and int(USER_AGE) <= 12:
                system_content = (
                    f"Voc√™ √© a ARIS, uma super-assistente de leitura **muito** brincalhona e divertida, ideal para crian√ßas. "
                    f"Seu nome √© {USER_NAME} e sua idade √© {USER_AGE}. Seu objetivo √© encorajar a leitura de forma l√∫dica. "
                    "Use emojis contextuais (üéâ, üìö, ‚ú®) para deixar a conversa mais animada. "
                    "Sempre responda de forma envolvente e sem usar negrito, it√°lico ou asteriscos na resposta final. "
                    "Mantenha um tom de melhor amiga/o aventureira/o."
                )
            else:
                system_content = (
                    f"Voc√™ √© a ARIS, uma assistente de leitura amig√°vel e atenciosa. "
                    f"Seu nome √© {USER_NAME} e sua idade √© {USER_AGE}. Sempre responda de forma envolvente e sem usar negrito, it√°lico ou asteriscos na resposta final. "
                    "Mantenha um tom adequado √† idade do usu√°rio."
                )
            messages = [
                {"role": "system", "content": system_content}
            ]
            
            max_history_length = 8
            if len(CHAT_HISTORY) > max_history_length:
                messages.extend(CHAT_HISTORY[-max_history_length:])
            else:
                messages.extend(CHAT_HISTORY)
            
            messages.append({"role": "user", "content": prompt})
        
        self.status_signal.emit("ARIS Pensando (LLM)...")
        self.activity_animation_signal.emit("thinking")
        
        pygame.mixer.music.play(loops=-1)
        
        try:
            # A chamada s√≠ncrona √© movida para uma thread separada pelo asyncio.to_thread
            completion = await asyncio.to_thread(
                client.chat.completions.create, 
                model="meta-llama/Meta-Llama-3-8B-Instruct", 
                messages=messages,
                max_tokens=500,
                temperature=0.9 
            )
            texto_resposta = completion.choices[0].message.content
            
            if "Analise:" not in prompt:
                CHAT_HISTORY.append({"role": "user", "content": prompt})
                CHAT_HISTORY.append({"role": "assistant", "content": texto_resposta})
            
        except Exception as e:
            # Esta exce√ß√£o captura erros de rede, autentica√ß√£o, cota, etc., durante a chamada LLM
            self.log_signal.emit(f"LOG: !!!!!!!! ERRO NA API HUGGING FACE: {e} !!!!!!!!")
            texto_resposta = "Desculpe, tive um problema ao processar sua solicita√ß√£o com a API. Verifique sua chave de acesso ou tente novamente."
        
        finally:
            await asyncio.sleep(0.3) 
            
            pygame.mixer.music.stop()
            if CONVERSA_ATIVA:
                self.status_signal.emit("Ouvindo...")
                self.activity_animation_signal.emit("idle")
        
        return texto_resposta.replace("*", "")

    # --- L√ìGICA DE RECOMENDA√á√ÉO ---
    async def realizar_recomendacao_dedicada(self, r, source):
        global USER_AGE, USER_NAME, RECOMENDADOR
        
        if client is None:
            await self.falar("Eu preciso do token de API para fazer a recomenda√ß√£o. Por favor, insira e conecte o seu token na interface.")
            return 
        
        if RECOMENDADOR is None or not RECOMENDADOR.carregado:
            await self.falar("O sistema de recomenda√ß√£o ainda n√£o foi carregado. Por favor, carregue a pasta do acervo processado na interface.")
            return

        await self.falar("Que √≥timo que voc√™ quer uma recomenda√ß√£o! Para acertar em cheio, preciso de algumas informa√ß√µes.")

        # 1. PERGUNTA 1: NOME E IDADE (Com mais tentativas)
        if USER_NAME == "Aluno" or USER_AGE == "N√£o informada":
            await self.falar("Para come√ßarmos, qual √© o seu nome e quantos anos voc√™ tem?")
            nome_e_idade_validado = False
            tentativas = 0
            while not nome_e_idade_validado and tentativas < MAX_TENTATIVAS:
                tentativas += 1
                resposta_usuario = await self.ouvir_e_reconhecer(r, source)
                if not resposta_usuario: 
                    if tentativas < MAX_TENTATIVAS:
                        await self.falar(f"Desculpe, n√£o entendi. Pode repetir seu nome e sua idade, por favor? (Tentativa {tentativas} de {MAX_TENTATIVAS})")
                    continue
                
                analise_nome_e_idade = await self.gerar_resposta_ia(
                    f"Analise: '{resposta_usuario}'. Extraia o nome e a idade em n√∫meros. Formato: Nome: [nome]\nIdade: [n] ou INVALIDA"
                )
                
                nome_match = re.search(r"Nome: (.*?)[\r\n]", analise_nome_e_idade)
                if nome_match and nome_match.group(1).strip().upper() not in ["NAO_IDENTIFICADO", "INVALIDO"]:
                    USER_NAME = nome_match.group(1).strip()
                
                idade_match = re.search(r"Idade: (\d+)", analise_nome_e_idade)
                if idade_match:
                    idade_str = idade_match.group(1).strip()
                    if idade_str.isdigit():
                        idade = int(idade_str)
                        if 3 <= idade <= 100: 
                            USER_AGE = str(idade)
                            
                if USER_NAME != "Aluno" and USER_AGE != "N√£o informada":
                    nome_e_idade_validado = True
                    self.user_info_signal.emit(USER_NAME, USER_AGE)
                    await self.falar(f"Entendido, {USER_NAME}! Com {USER_AGE} anos. Que legal!")
                elif tentativas < MAX_TENTATIVAS:
                    await self.falar("Ainda n√£o consegui entender bem. Lembre-se, me diga seu nome e a sua idade em n√∫meros. Vamos tentar de novo.")
            
            if not nome_e_idade_validado:
                await self.falar(f"Tudo bem, usarei o nome '{USER_NAME}' e uma recomenda√ß√£o mais ampla. N√£o se preocupe.")
        else:
            await self.falar(f"Certo, {USER_NAME}, sua idade ({USER_AGE} anos) j√° est√° anotada.")


        # 2. PERGUNTA 2: GOSTOS (Com mais tentativas)
        await self.falar(f"Agora, {USER_NAME}: que tipo de hist√≥rias, como aventura, fantasia ou ci√™ncia, voc√™ mais gosta de ler?")
        gostos = ""
        tentativas = 0
        while not gostos and tentativas < MAX_TENTATIVAS:
            tentativas += 1
            resposta_usuario = await self.ouvir_e_reconhecer(r, source)
            
            if resposta_usuario:
                gostos = resposta_usuario
            elif tentativas < MAX_TENTATIVAS:
                await self.falar(f"N√£o entendi seus gostos. Tente me dar um exemplo do tipo de livro que voc√™ gosta. (Tentativa {tentativas} de {MAX_TENTATIVAS})")
        
        if not gostos:
            gostos = "livros de aventura e fic√ß√£o geral" 
            await self.falar("Como n√£o consegui ouvir seus gostos, vou usar meus conhecimentos para sugerir algo que combine com voc√™. Buscando recomenda√ß√µes...")
        else:
            await self.falar("Perfeito! Buscando as melhores recomenda√ß√µes que combinem com tudo isso...")
            
        # 3. GERA RECOMENDA√á√ÉO USANDO BUSCA VETORIAL
        livros_recomendados = RECOMENDADOR.recomendar(gostos, top_k=5)
        
        if not livros_recomendados:
            await self.falar("Puxa, n√£o consegui encontrar livros que combinem com o que voc√™ pediu no nosso acervo. Que tal tentarmos outro tema?")
            return

        # 4. **PROMPT SUPER RESTRITIVO PARA O LLM**
        self.log_signal.emit("LOG: Top 5 livros da busca vetorial enviados para o LLM.")
        
        lista_livros_para_ia = ""
        for i, livro in enumerate(livros_recomendados):
            lista_livros_para_ia += f"{i+1}. T√≠tulo: {livro['titulo_original']}\n"
            lista_livros_para_ia += f"   Autor: {livro['autor']}\n"
            lista_livros_para_ia += f"   G√™neros: {livro['generos']}\n"
            descricao_curta = str(livro['descricao'])[:200] + '...' if len(str(livro['descricao'])) > 200 else str(livro['descricao'])
            lista_livros_para_ia += f"   Descri√ß√£o: {descricao_curta}\n\n"

        prompt_final = (
            f"Voc√™ √© a assistente de leitura ARIS. Sua tarefa √© apresentar uma recomenda√ß√£o de livros para o aluno {USER_NAME} ({USER_AGE} anos), que gosta de '{gostos}'.\n"
            f"Abaixo est√° uma lista com os 5 livros mais relevantes do nosso acervo. Voc√™ DEVE escolher 2 ou 3 livros EXCLUSIVAMENTE desta lista.\n"
            "√â absolutamente proibido sugerir ou mencionar QUALQUER livro que n√£o esteja nesta lista.\n\n"
            "--- LISTA DE LIVROS PERMITIDOS ---\n"
            f"{lista_livros_para_ia}"
            "--- FIM DA LISTA ---\n\n"
            "Sua tarefa: Agora, fale diretamente com o {USER_NAME}. De uma forma amig√°vel e apropriada para a idade (lembre-se se deve ser brincalhona ou n√£o), apresente 2 ou 3 dos livros da lista acima. Explique brevemente por que eles combinam com os gostos do usu√°rio. Comece a sua resposta diretamente, sem introdu√ß√µes como 'Claro!' ou 'Com certeza!'."
        )
        
        msg = await self.gerar_resposta_ia(prompt_final)
        await self.falar(msg)
        
        await self.falar("Espero que goste! O que mais voc√™ gostaria de saber ou conversar?")

    # --- M√©todos de Controle da Thread (Escuta de Ativa√ß√£o) ---
    def _ouvir_palavra_de_ativacao(self):
        with sr.Microphone() as source:
            self.r.adjust_for_ambient_noise(source, duration=1)
            self.log_signal.emit("LOG: üéôÔ∏è Ouvindo para 'E a√≠ Aris'...")
            self.status_signal.emit("Aguardando 'E a√≠ Aris'...")
            self.activity_animation_signal.emit("idle") 
            
            while self._is_running:
                if client is None:
                    time.sleep(1) 
                    continue 

                if not CONVERSA_ATIVA:
                    try:
                        audio = self.r.listen(source, timeout=8, phrase_time_limit=4)
                        texto = self.r.recognize_google(audio, language="pt-BR").lower()
                        texto_sem_acento = remover_acentos(texto)
                        
                        if any(similar(texto_sem_acento, frase) > 0.6 for frase in ["e ai aris", "ei aris", "eai aris", "hey aris", "aris"]):
                            self.log_signal.emit("LOG: ‚úÖ Palavra de ativa√ß√£o detectada!")
                            self.start_main_conversation()
                            
                    except sr.WaitTimeoutError:
                        pass
                    except Exception:
                        pass
                    
                    time.sleep(0.1) 
                else:
                    time.sleep(0.5) 

    def start_asyncio_loop(self):
        global main_async_loop
        main_async_loop = asyncio.new_event_loop()
        asyncio.set_event_loop(main_async_loop)
        main_async_loop.run_forever()

    def start_main_conversation(self):
        global CONVERSA_ATIVA, main_async_loop
        if client is None:
              self.log_signal.emit("LOG: Conversa bloqueada. API n√£o conectada.")
              return
              
        if not CONVERSA_ATIVA and main_async_loop and main_async_loop.is_running():
            CONVERSA_ATIVA = True
            asyncio.run_coroutine_threadsafe(self.main_async(), main_async_loop)

    def stop(self):
        self._is_running = False
        global main_async_loop
        if main_async_loop and main_async_loop.is_running():
            main_async_loop.call_soon_threadsafe(main_async_loop.stop)

    async def main_async(self):
        global CONVERSA_ATIVA
        self.status_signal.emit("Inicializando Microfone...")
        
        if client is None:
              self.log_signal.emit("LOG: Tentativa de iniciar conversa sem API. Encerrando ciclo.")
              self._reiniciar_conversa()
              return

        with sr.Microphone() as source:
            self.r.adjust_for_ambient_noise(source, duration=2.0)
            
            await self.falar(random.choice([
                "Ol√°! Eu sou a ARIS e estou pronta. O que voc√™ gostaria de conversar hoje?", 
                "Oi, sou a ARIS, sua assistente de leitura. Em que posso te ajudar?",
                "Tudo pronto aqui! √â s√≥ me dizer o que precisa."
            ]))
            
            MAX_CONV_ATTEMPTS = 3 # M√°ximo de tentativas para ouvir o usu√°rio

            # --- CORRE√á√ÉO: ENVOLVER O LOOP EM TRY-EXCEPT PARA EVITAR CRASHES ---
            while CONVERSA_ATIVA:
                try:
                    tentativas = 0
                    resposta_usuario = ""

                    # NOVO LOOP PARA PEDIR REPETI√á√ÉO
                    while not resposta_usuario and tentativas < MAX_CONV_ATTEMPTS:
                        tentativas += 1
                        
                        # 1. Tenta ouvir e reconhecer
                        resposta_usuario = await self.ouvir_e_reconhecer(self.r, source)
                        
                        if not resposta_usuario and tentativas < MAX_CONV_ATTEMPTS:
                            # 2. Se falhar e ainda houver tentativas, pede para repetir
                            await self.falar(f"Desculpe, n√£o consegui te ouvir. Poderia repetir o que voc√™ disse? (Tentativa {tentativas} de {MAX_CONV_ATTEMPTS})")
                        elif not resposta_usuario and tentativas == MAX_CONV_ATTEMPTS:
                            # 3. Se esgotar as tentativas, encerra a conversa
                            await self.falar("Parece que a comunica√ß√£o est√° dif√≠cil. Vou encerrar a conversa por enquanto. Me chame de novo quando quiser.")
                            break # Sai do loop interno

                    if not resposta_usuario: # Saiu do loop interno sem resposta v√°lida
                        break # Sai do loop principal CONVERSA_ATIVA

                    if any(comando in remover_acentos(resposta_usuario).lower() for comando in ["sair", "parar", "tchau", "encerrar", "finalizar"]):
                        await self.falar("Tudo bem, foi √≥timo conversar com voc√™! Me chame de novo quando quiser.")
                        break

                    gatilhos_recomendacao = ["recomendar livro", "me da um livro", "recomendacao", "qual livro eu leio", "sugestao de leitura", "recomendo", "recomenda", "recomende"]

                    if any(comando in remover_acentos(resposta_usuario).lower() for comando in gatilhos_recomendacao):
                        self.log_signal.emit("LOG: ‚úÖ Gatilho de recomenda√ß√£o detectado.")
                        await self.realizar_recomendacao_dedicada(self.r, source)
                    else:
                        msg = await self.gerar_resposta_ia(resposta_usuario)
                        await self.falar(msg)

                except Exception as e:
                    self.log_signal.emit(f"LOG: ERRO CR√çTICO NO CICLO PRINCIPAL (LLM/FALA): {e}")
                    # Mensagem de recupera√ß√£o para o usu√°rio
                    await self.falar("Desculpe, tive um erro inesperado e preciso reiniciar a conversa. Por favor, me chame de novo.")
                    break # Sai do loop, for√ßando o rein√≠cio da conversa
                    
        self._reiniciar_conversa()
        
    def _reiniciar_conversa(self):
        global CONVERSA_ATIVA, CHAT_HISTORY, USER_NAME, USER_AGE
        CONVERSA_ATIVA = False
        CHAT_HISTORY = [] 
        USER_NAME = "Aluno"
        USER_AGE = "N√£o informada"
        pygame.mixer.music.stop()
        
        if client is not None:
              self.status_signal.emit("Finalizada. Aguardando ativa√ß√£o (voz ou manual)...")
        else:
              self.status_signal.emit("Aguardando Token API para iniciar...")
              
        self.user_info_signal.emit(USER_NAME, USER_AGE) 
        self.activity_animation_signal.emit("idle") 
        
# ====================================================================
# 6. JANELA PRINCIPAL (PyQt6) - COM FONTES PADRONIZADAS E SEM ARDUINO
# ====================================================================

class ArisWindow(QMainWindow):
    
    def __init__(self, modelo_precarregado):
        # REMOVIDA A PORTA ARDUINO DO CONSTRUTOR
        self.modelo_precarregado = modelo_precarregado
        
        super().__init__()
        self.setWindowTitle("ARIS - Assistente de Leitura")
        self.setGeometry(100, 100, 900, 750) 
        
        self.default_font = "Arial" 

        # --- Folha de Estilo com Padroniza√ß√£o de Fontes (12px) ---
        self.setStyleSheet(f"""
            QMainWindow {{ background-color: {ArisConfig.BACKGROUND_COLOR}; font-family: '{self.default_font}';}}
            
            /* PADRONIZA√á√ÉO DE FONTE GERAL (EXCETO T√çTULO) */
            QLabel, QPushButton, QLineEdit, QFrame {{ 
                color: {ArisConfig.TEXT_COLOR};
                font-size: 14px;
            }}
            
            /* NOVO ESTILO PARA LABELS DE API */
            QLabel#ApiLabel {{
                background-color: {ArisConfig.PRIMARY_COLOR}; /* Fundo vermelho */
                color: #000000; /* Texto branco para contraste */
                padding: 5px;
                border-radius: 5px;
                font-weight: bold;
            }}
            
            QFrame#HeaderFrame {{ 
                background-color: {ArisConfig.PRIMARY_COLOR};
                border: none;
                padding: 10px; 
                border-radius: 0px; 
            }}
            
            QLabel#TitleLabel {{ 
                color: {ArisConfig.TEXT_COLOR};
                font-size: 34px; /* Maior */
                font-weight: bold; 
                padding-left: 10px;
            }}
            
           /* ESTILO PARA CAMPOS DE TEXTO (API E LOG) */
            QTextEdit, QLineEdit {{ 
                background-color: #FFFFFF;
                border: 1px solid {ArisConfig.ACCENT_COLOR}; 
                border-radius: 8px; 
                padding: 10px; 
                color: #333333; 
                font-size: 14px;
            }}
            
            QFrame {{ background-color: {ArisConfig.WIDGET_COLOR}; border-radius: 8px; border: 1px solid {ArisConfig.WIDGET_COLOR}; }}
            QFrame#ChatFrame, QFrame#ApiFrame {{ border: 1px solid {ArisConfig.ACCENT_COLOR}; box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3); }}
            
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 {ArisConfig.ACCENT_COLOR}, stop:1 {ArisConfig.PRIMARY_COLOR});
                color: {ArisConfig.TEXT_COLOR}; border-radius: 8px; padding: 10px 20px; font-weight: bold; border: none;
                font-size: 12px; /* Padronizado */
            }}
            QPushButton:hover {{ 
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 {ArisConfig.PRIMARY_COLOR}, stop:1 {ArisConfig.ACCENT_COLOR}); 
            }}
            
            QLabel#StatusLabel {{
                color: {ArisConfig.ACCENT_COLOR}; 
                font-size: 14px; /* Mantido um pouco maior para destaque */
                font-weight: bold;
            }}
        """)

        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(15, 15, 15, 15) 
        main_layout.setSpacing(15) 
        
        self.log_area = QTextEdit()
        self.log_area.setReadOnly(True)
        self.log_area.setFont(QFont(self.default_font, 11))
        
        # --- Header ---
        header_frame = QFrame()
        header_frame.setObjectName("HeaderFrame")
        header_layout = QHBoxLayout(header_frame)
        header_layout.setContentsMargins(15, 5, 15, 5)
        
        self.title_label = QLabel("ARIS - Assistente de Leitura")
        self.title_label.setObjectName("TitleLabel")
        header_layout.addWidget(self.title_label)
        
        header_layout.addStretch() 
        
        # --- Logo (250x60) ---
        self.animation_label = QLabel()
        self.movie = QMovie(os.path.join(ArisConfig.ASSETS_DIR, "listening.gif"))
        self.animation_label.setMovie(self.movie)
        self.animation_label.setFixedSize(150, 60) 
        self.animation_label.setScaledContents(True) 

        header_layout.addWidget(self.animation_label)
        
        # --- Status Label (abaixo da anima√ß√£o) ---
        self.status_label = QLabel("")
        self.status_label.setObjectName("StatusLabel") 
        
        header_layout.addWidget(self.status_label) # <-- ONDE O ERRO ANTERIOR PODE TER OCORRIDO
        
        
        main_layout.addWidget(header_frame)
        
        # --- Configura√ß√£o do Token de API ---
        api_frame = QFrame()
        api_frame.setObjectName("ApiFrame")
        api_layout = QHBoxLayout(api_frame)
        api_layout.setContentsMargins(10, 10, 10, 10)
        
        # 1. Hugging Face/OpenAI API
        self.hf_token_input = QLineEdit()
        self.hf_token_input.setPlaceholderText("HF/OpenAI Token (LLM)")
        
        llm_label = QLabel("LLM API Token:")
        llm_label.setObjectName("ApiLabel") # <--- ESTILO APLICADO
        api_layout.addWidget(llm_label)
        
        api_layout.addWidget(self.hf_token_input, 3) 

        self.connect_hf_button = QPushButton("Conectar LLM API")
        self.connect_hf_button.clicked.connect(self.connect_hf_api)
        api_layout.addWidget(self.connect_hf_button, 1) 
        
        api_layout.addWidget(QLabel("|")) # Separador visual
        
        # 2. Google Books API (used by Acervo Processor)
        self.google_api_key_input = QLineEdit()
        self.google_api_key_input.setPlaceholderText("Google Books API Key")
        self.google_api_key_for_worker = ""
        
        google_label = QLabel("Google API Key:")
        google_label.setObjectName("ApiLabel") # <--- ESTILO APLICADO
        api_layout.addWidget(google_label)
        
        api_layout.addWidget(self.google_api_key_input, 3) 
        
        self.connect_google_button = QPushButton("Conectar Google API") # <--- NOVO BOT√ÉO
        self.connect_google_button.clicked.connect(self.connect_google_api)
        api_layout.addWidget(self.connect_google_button, 1)
        
        main_layout.addWidget(api_frame)
        
        self.update_log("LOG: Sistema inicializado. Conecte as APIs para come√ßar.")
      
        
        # --- √ÅREA DE PROCESSAMENTO E CARREGAMENTO ---
        acervo_frame = QFrame()
        acervo_frame.setObjectName("ApiFrame")
        acervo_layout = QHBoxLayout(acervo_frame)
        
        self.process_excel_button = QPushButton("Processar Novo Acervo (Excel)")
        self.process_excel_button.clicked.connect(self.iniciar_processamento_acervo)
        acervo_layout.addWidget(self.process_excel_button)
        
        self.acervo_status_label = QLabel("Nenhum acervo processado.")
        acervo_layout.addWidget(self.acervo_status_label)
        acervo_layout.addStretch()

        main_layout.addWidget(acervo_frame)
        
        # --- √Årea de Log/Chat ---
        chat_frame = QFrame()
        chat_frame.setObjectName("ChatFrame")
        chat_layout = QVBoxLayout(chat_frame)
        chat_layout.setContentsMargins(10, 10, 10, 10)
        
        chat_layout.addWidget(self.log_area)
        
        main_layout.addWidget(chat_frame) 
        
        # --- Painel Inferior (S√≥ com Bot√µes) ---
        bottom_panel_layout = QHBoxLayout()
        bottom_panel_layout.setSpacing(15)
        
        buttons_frame = QFrame()
        buttons_frame.setObjectName("ButtonsFrame")
        buttons_layout = QHBoxLayout(buttons_frame)
        buttons_layout.setContentsMargins(10, 10, 10, 10)
        
        self.start_button = QPushButton("Ativar ARIS (Manual)")
        self.start_button.setIcon(QIcon(os.path.join(ArisConfig.ASSETS_DIR, "activate_icon.png")))
        self.start_button.clicked.connect(self.manual_start)
        
        self.exit_button = QPushButton("Encerrar")
        self.exit_button.setStyleSheet(f"background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 {ArisConfig.ERROR_COLOR}, stop:1 #B00020);")
        self.exit_button.setIcon(QIcon(os.path.join(ArisConfig.ASSETS_DIR, "exit_icon.png")))
        self.exit_button.clicked.connect(self.close)
        
        buttons_layout.addWidget(self.start_button)
        buttons_layout.addWidget(self.exit_button)
        buttons_frame.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        bottom_panel_layout.addWidget(buttons_frame) 

        main_layout.addLayout(bottom_panel_layout)

        # 7. INICIALIZAR WORKERS E SINAIS (SEM ARDUINO)
        self.aris_worker = ArisWorker()
        self.aris_thread = QThread()
        self.aris_worker.moveToThread(self.aris_thread)
        self.aris_worker.log_signal.connect(self.update_log)
        self.aris_worker.status_signal.connect(self.update_status)
        self.aris_worker.activity_animation_signal.connect(self.set_animation)
        self.aris_worker.user_info_signal.connect(self.update_user_info)
        self.aris_thread.started.connect(self.aris_worker.start_asyncio_loop)
        self.aris_thread.start()
        
        
        self.set_animation("idle") 

    # --- SLOTS DA UI PARA API ---
    def connect_hf_api(self):
        token = self.hf_token_input.text().strip()
        if not token:
            self.update_log("LOG: ERRO - Token de API LLM est√° vazio.")
            return

        self.update_log("LOG: Tentando conectar a API do LLM...")
        if inicializar_cliente_hf(token):
            self.update_log("LOG: ‚úÖ API LLM conectada com sucesso!")
            self.update_status("API Conectada! Diga 'E a√≠ Aris' ou pressione Ativar.")
            self.connect_hf_button.setEnabled(False)
            self.hf_token_input.setEnabled(False)
            
            # Inicia a thread de escuta do microfone
            if not self.aris_worker.mic_thread.is_alive():
                 self.aris_worker.mic_thread.start()
        else:
            self.update_log("LOG: ‚ùå Falha ao conectar a API LLM. Verifique o token e a URL base.")
            
    def connect_google_api(self):
        google_api_key = self.google_api_key_input.text().strip()
        if not google_api_key:
            self.update_log("LOG: ERRO - O campo da Google Books API est√° vazio.")
            self.acervo_status_label.setText("Chave Google API pendente. ‚ùå")
            self.acervo_status_label.setStyleSheet(f"color: {ArisConfig.ERROR_COLOR};")
            return

        self.google_api_key_for_worker = google_api_key
        self.update_log("LOG: ‚úÖ Chave Google Books API registrada com sucesso!")
        self.acervo_status_label.setText("Chave Google API registrada. Prossiga com o acervo. ‚úÖ")
        self.acervo_status_label.setStyleSheet("color: #008000;")
        self.connect_google_button.setEnabled(False)
        self.google_api_key_input.setEnabled(False)
            

    # --- SLOTS DA UI (Existentes) ---
    def update_log(self, text):
        self.log_area.append(text)
        
    def update_status(self, text):
        self.status_label.setText(text)

    def update_user_info(self, name, age):
        # Esta fun√ß√£o agora est√° vazia na interface, mas mant√©m o sinal para evitar erros
        pass 
        
    def set_animation(self, state):
        self.movie.stop()
        self.animation_label.setMovie(None) 
        self.animation_label.setPixmap(QPixmap()) 
        
        current_gif_path = "" 

        if state == "listening":
            current_gif_path = os.path.join(ArisConfig.ASSETS_DIR, "listening.gif")
            
        elif state == "thinking":
            current_gif_path = ArisConfig.THINKING_GIF_PATH 
            
        elif state == "talking":
            talking_path = os.path.join(ArisConfig.ASSETS_DIR, "talking.gif")
            if os.path.exists(talking_path):
                current_gif_path = talking_path
            else:
                current_gif_path = os.path.join(ArisConfig.ASSETS_DIR, "listening.gif")
            
        else: # Estado IDLE (Logo Est√°tica - Proporcional)
            profile_path = ArisConfig.PROFILE_PIC_PATH
            if os.path.exists(profile_path):
                pixmap = QPixmap(profile_path)
                scaled_pixmap = pixmap.scaled(self.animation_label.size(), 
                                               Qt.AspectRatioMode.KeepAspectRatio, 
                                               Qt.TransformationMode.SmoothTransformation)
                
                self.animation_label.setPixmap(scaled_pixmap)
                
                return 

        if current_gif_path and current_gif_path.lower().endswith(('.gif', '.png')): 
              self.movie.setFileName(current_gif_path)
              self.animation_label.setMovie(self.movie)
              self.movie.start()

    def iniciar_processamento_acervo(self):
        google_api_key = self.google_api_key_for_worker 
        if not google_api_key:
            self.update_log("LOG: ERRO - A chave da Google Books API n√£o foi configurada.")
            self.update_status("Chave Google API n√£o configurada.")
            return

        file_path, _ = QFileDialog.getOpenFileName(self, "Selecionar Arquivo Excel do Acervo", "", "Excel Files (*.xlsx)")
        
        if file_path:
            self.process_excel_button.setEnabled(False)
            output_dir = os.path.join(os.path.dirname(file_path), "acervo_processado")
            os.makedirs(output_dir, exist_ok=True)
            
            self.processor_thread = QThread()
            self.processor_worker = AcervoProcessorWorker(file_path, output_dir, google_api_key)
            self.processor_worker.moveToThread(self.processor_thread)
            
            self.processor_worker.log_signal.connect(self.update_log)
            self.processor_worker.progress_signal.connect(self.update_status)
            self.processor_worker.finished_signal.connect(self.processamento_finalizado)
            
            self.processor_thread.started.connect(self.processor_worker.run)
            self.processor_thread.start()

    def processamento_finalizado(self, sucesso, path_ou_erro):
        global RECOMENDADOR
        if sucesso:
            self.update_log("LOG: Processamento conclu√≠do com sucesso! Carregando recomendador...")
            RECOMENDADOR = RecomendadorVetorial(path_ou_erro, self.modelo_precarregado) 
            if RECOMENDADOR.carregar_modelo_e_dados():
                num_livros = len(RECOMENDADOR.acervo_df)
                self.acervo_status_label.setText(f"{num_livros} livros prontos para recomenda√ß√£o! ‚úÖ")
                self.acervo_status_label.setStyleSheet("color: #008000;")
            else:
                self.acervo_status_label.setText("Erro ao carregar dados processados. ‚ùå")
                self.acervo_status_label.setStyleSheet(f"color: {ArisConfig.ERROR_COLOR};")
        else:
            self.update_log(f"LOG: Falha no processamento: {path_ou_erro}")
            self.update_status("Falha no processamento.")
        
        self.process_excel_button.setEnabled(True)
        self.processor_thread.quit()
        self.processor_thread.wait()

    def manual_start(self):
        if not client:
            self.update_log("LOG: AVISO: API n√£o conectada. Conecte o Token LLM para usar a ARIS.")
            return
        if not CONVERSA_ATIVA:
            self.aris_worker.start_main_conversation()

    def closeEvent(self, event):
        self.aris_worker.stop()
        self.aris_thread.quit()
        self.aris_thread.wait()
        pygame.quit()
        event.accept()

# ====================================================================
# 7. BLOCO PRINCIPAL DE EXECU√á√ÉO
# ====================================================================

if __name__ == "__main__":
    # Garante que o diret√≥rio de assets exista
    if not os.path.exists(ArisConfig.ASSETS_DIR):
        print(f"ATEN√á√ÉO: Diret√≥rio de assets '{ArisConfig.ASSETS_DIR}' n√£o encontrado. A interface pode n√£o carregar corretamente.")

    app = QApplication(sys.argv)
    
    # 1. Cria e mostra a tela de Splash
    splash = SplashScreen()
    splash.move(app.primaryScreen().geometry().center() - splash.rect().center())
    splash.show()
    
    # 2. Prepara o worker de inicializa√ß√£o
    init_thread = QThread()
    init_worker = InitializationWorker()
    init_worker.moveToThread(init_thread)
    
    # 3. Conecta os sinais do worker √† splash screen e √† l√≥gica principal
    init_worker.progress_updated.connect(lambda p, s: (splash.set_progress(p), splash.set_status(s)))
    
    main_window = None
    
    def on_initialization_finished(modelo):
        global main_window
        if modelo:
            # REMOVIDA A PORTA ARDUINO DA INSTANCIA√á√ÉO
            main_window = ArisWindow(modelo)
            main_window.show()
        else:
            print("N√£o foi poss√≠vel carregar o modelo de IA. Encerrando aplica√ß√£o.")
            app.quit()
        
        splash.close()
        init_thread.quit()
        init_thread.wait()

    init_worker.finished.connect(on_initialization_finished)
    
    # 4. Inicia o trabalho pesado em segundo plano
    init_thread.started.connect(init_worker.run)
    init_thread.start()

    sys.exit(app.exec())
